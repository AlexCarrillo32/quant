//! Trading signal types

use super::{Price, Quantity, Symbol, ValidationError};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::fmt;

/// Trading signal action
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum SignalAction {
    /// Buy signal
    Buy,
    /// Sell signal
    Sell,
    /// Close position
    Close,
    /// Hold/do nothing
    Hold,
}

impl fmt::Display for SignalAction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SignalAction::Buy => write!(f, "BUY"),
            SignalAction::Sell => write!(f, "SELL"),
            SignalAction::Close => write!(f, "CLOSE"),
            SignalAction::Hold => write!(f, "HOLD"),
        }
    }
}

/// Confidence score (0.0 to 1.0)
///
/// Represents how confident we are in this signal
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize)]
pub struct Confidence(f64);

impl Confidence {
    /// Create new confidence score
    ///
    /// # Errors
    ///
    /// Returns error if value is not in [0.0, 1.0] range
    pub fn new(value: f64) -> Result<Self, ValidationError> {
        if !(0.0..=1.0).contains(&value) {
            return Err(ValidationError::InvalidConfidence(value));
        }
        Ok(Confidence(value))
    }

    /// Low confidence (< 0.5)
    #[inline(always)]
    pub fn is_low(&self) -> bool {
        self.0 < 0.5
    }

    /// Medium confidence (0.5 - 0.75)
    #[inline(always)]
    pub fn is_medium(&self) -> bool {
        (0.5..=0.75).contains(&self.0)
    }

    /// High confidence (> 0.75)
    #[inline(always)]
    pub fn is_high(&self) -> bool {
        self.0 > 0.75
    }

    #[inline(always)]
    pub fn value(&self) -> f64 {
        self.0
    }

    /// Convert to percentage
    pub fn as_percent(&self) -> f64 {
        self.0 * 100.0
    }
}

impl fmt::Display for Confidence {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:.1}%", self.as_percent())
    }
}

/// Trading signal with metadata
///
/// Generated by alpha models to indicate trading opportunities
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signal {
    /// Symbol to trade
    pub symbol: Symbol,

    /// Action to take
    pub action: SignalAction,

    /// Signal confidence (0-1)
    pub confidence: Confidence,

    /// When signal was generated
    pub timestamp: DateTime<Utc>,

    /// Target price (if applicable)
    pub target_price: Option<Price>,

    /// Stop loss price (if applicable)
    pub stop_loss: Option<Price>,

    /// Take profit price (if applicable)
    pub take_profit: Option<Price>,

    /// Suggested quantity
    pub quantity: Option<Quantity>,

    /// Human-readable reason
    pub reason: String,

    /// Alpha model that generated this
    pub source: String,

    /// Additional metadata
    pub metadata: serde_json::Value,
}

impl Signal {
    /// Create a new signal
    pub fn new(
        symbol: Symbol,
        action: SignalAction,
        confidence: Confidence,
        reason: impl Into<String>,
        source: impl Into<String>,
    ) -> Self {
        Signal {
            symbol,
            action,
            confidence,
            timestamp: Utc::now(),
            target_price: None,
            stop_loss: None,
            take_profit: None,
            quantity: None,
            reason: reason.into(),
            source: source.into(),
            metadata: serde_json::Value::Null,
        }
    }

    /// Builder pattern for optional fields
    pub fn with_target_price(mut self, price: Price) -> Self {
        self.target_price = Some(price);
        self
    }

    pub fn with_stop_loss(mut self, price: Price) -> Self {
        self.stop_loss = Some(price);
        self
    }

    pub fn with_take_profit(mut self, price: Price) -> Self {
        self.take_profit = Some(price);
        self
    }

    pub fn with_quantity(mut self, quantity: Quantity) -> Self {
        self.quantity = Some(quantity);
        self
    }

    pub fn with_metadata(mut self, metadata: serde_json::Value) -> Self {
        self.metadata = metadata;
        self
    }

    /// Check if signal is actionable (high confidence, not hold)
    pub fn is_actionable(&self) -> bool {
        self.action != SignalAction::Hold && self.confidence.is_high()
    }

    /// Calculate risk/reward ratio if prices are available
    pub fn risk_reward_ratio(&self, current_price: Price) -> Option<f64> {
        let target = self.target_price?;
        let stop = self.stop_loss?;

        let reward = target.value() - current_price.value();
        let risk = current_price.value() - stop.value();

        if risk > 0.0 {
            Some(reward / risk)
        } else {
            None
        }
    }
}

impl fmt::Display for Signal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "[{}] {} {} (confidence: {}) - {}",
            self.source, self.action, self.symbol, self.confidence, self.reason
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_confidence_validation() {
        assert!(Confidence::new(0.0).is_ok());
        assert!(Confidence::new(0.5).is_ok());
        assert!(Confidence::new(1.0).is_ok());

        assert!(Confidence::new(-0.1).is_err());
        assert!(Confidence::new(1.1).is_err());
    }

    #[test]
    fn test_confidence_levels() {
        let low = Confidence::new(0.3).unwrap();
        assert!(low.is_low());
        assert!(!low.is_medium());
        assert!(!low.is_high());

        let medium = Confidence::new(0.6).unwrap();
        assert!(!medium.is_low());
        assert!(medium.is_medium());
        assert!(!medium.is_high());

        let high = Confidence::new(0.9).unwrap();
        assert!(!high.is_low());
        assert!(!high.is_medium());
        assert!(high.is_high());
    }

    #[test]
    fn test_signal_creation() {
        let symbol = Symbol::new("AAPL").unwrap();
        let confidence = Confidence::new(0.85).unwrap();

        let signal = Signal::new(
            symbol,
            SignalAction::Buy,
            confidence,
            "Strong buy signal",
            "TestAlpha",
        );

        assert_eq!(signal.action, SignalAction::Buy);
        assert!(signal.confidence.is_high());
        assert!(signal.is_actionable());
    }

    #[test]
    fn test_risk_reward_ratio() {
        let symbol = Symbol::new("AAPL").unwrap();
        let confidence = Confidence::new(0.85).unwrap();

        let signal = Signal::new(symbol, SignalAction::Buy, confidence, "Test", "TestAlpha")
            .with_target_price(Price::new(110.0).unwrap())
            .with_stop_loss(Price::new(95.0).unwrap());

        let current = Price::new(100.0).unwrap();
        let rr = signal.risk_reward_ratio(current).unwrap();

        // Reward: 110 - 100 = 10
        // Risk: 100 - 95 = 5
        // R:R = 10/5 = 2.0
        assert_eq!(rr, 2.0);
    }

    #[test]
    fn test_hold_not_actionable() {
        let symbol = Symbol::new("AAPL").unwrap();
        let confidence = Confidence::new(0.9).unwrap();

        let signal = Signal::new(symbol, SignalAction::Hold, confidence, "Hold", "TestAlpha");

        assert!(!signal.is_actionable());
    }
}
